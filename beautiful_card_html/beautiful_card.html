<!DOCTYPE html>
<html lang="zh-CN">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Beautiful Card</title>
		<script src="qrc:///qtwebchannel/qwebchannel.js"></script>
		<style>
			/* æ¸å˜åœæ­¢ç‚¹åŠ¨ç”» */
			@keyframes gradientStopAnimation {
				0% {
					--gradient-stop: 10%;
				}
				100% {
					--gradient-stop: 50%;
				}
			}

			@keyframes gradientStopAnimationReverse {
				0% {
					--gradient-stop: 50%;
				}
				100% {
					--gradient-stop: 10%;
				}
			}

			:root {
				--theme-color: #007acc;
				--file-color: #ffffff;
				--unit-round-corner: 16px;
			}

			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
				user-select: none;
				-webkit-user-drag: none;
			}

			body {
				width: 100vw;
				height: 100vh;
				overflow: hidden;
				background: transparent;
				font-family: "Segoe UI", "Microsoft YaHei", sans-serif;
				display: flex;
				align-items: center;
				justify-content: flex-start; /* å·¦å¯¹é½ */
			}

			/* ä¸»å¡ç‰‡å®¹å™¨ */
			.card {
				position: relative;
				display: flex;
				align-items: center;
				justify-content: center; /* æ¨ªå‘å±…ä¸­ */

				left: 0%;
				height: 100%; /* ç•™ä¸€ç‚¹è¾¹è· */
				width: 100%;
				/* padding: 6px; */

				border-radius: var(--unit-round-corner);

				/* ç»ç’ƒæ‹Ÿæ€èƒŒæ™¯ */
				/* background: var(--mixed-bg); */
				/* backdrop-filter: blur(12px); */
				/* -webkit-backdrop-filter: blur(12px); */

				border: 2px solid rgba(255, 255, 255, 0.2);
				/* box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); */

				/* æ¸å˜èƒŒæ™¯ä½¿ç”¨ CSS å˜é‡ï¼Œæ”¯æŒåŠ¨ç”»æ’å€¼ */
				--gradient-color1: rgba(0, 122, 204, 0.4);
				--gradient-color2: rgba(0, 122, 204, 0.1);
				--gradient-stop: 10%;
				/* Icon èƒŒæ™¯ç›¸å…³å˜é‡ */
				--icon-bg-url: none;
				--icon-bg-opacity: 0;

				background: linear-gradient(
					135deg,
					var(--gradient-color1) 0%,
					var(--gradient-color1) var(--gradient-stop),
					var(--gradient-color2) 100%
				);

				transition: border-color 0.4s cubic-bezier(0.25, 0.8, 0.25, 1),
					--icon-bg-opacity 0.6s cubic-bezier(0.25, 0.8, 0.25, 1),
					--gradient-stop 0.6s cubic-bezier(0.25, 0.8, 0.25, 1);
				cursor: pointer;
				overflow: hidden;
				&.focused {
					--gradient-stop: 50%;
					border-color: rgba(255, 255, 255, 0.4);
				}
				&:active {
					--gradient-stop: 90%;
					border-color: rgba(255, 255, 255, 0.147);
				}
			}

			/* Icon èƒŒæ™¯å±‚ - ä½¿ç”¨ä¼ªå…ƒç´ å®ç° */
			.card::before {
				content: "";
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				border-radius: var(--unit-round-corner);
				background-image: var(--icon-bg-url);
				background-size: 40%;
				background-position: center;
				background-repeat: no-repeat;
				opacity: var(--icon-bg-opacity);
				pointer-events: none;
				z-index: 1;
				transition: opacity 0.6s cubic-bezier(0.25, 0.8, 0.25, 1);
			}

			/* å›¾æ ‡å®¹å™¨ */
			.icon-wrapper {
				height: 60%;
				aspect-ratio: 1;
				flex-shrink: 0;
				border-radius: var(--unit-round-corner);
				display: flex;
				align-items: center;
				justify-content: center;
				background: rgba(255, 255, 255, 0.15);
				box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.1);
				z-index: 2;
				transition: transform 0.4s ease;
				&:hover {
					transform: scale(1.2);
				}
			}

			.icon-img {
				width: 80%;
				height: 80%;
				object-fit: contain;
				filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
			}

			/* æ–‡æœ¬å®¹å™¨ - é»˜è®¤éšè—çŠ¶æ€ */
			.info-wrapper {
				display: flex;
				flex-direction: column;
				justify-content: center;
				padding-right: 10px;

				/* åŠ¨ç”»å…³é”®å±æ€§ - ä½¿ç”¨ CSS å˜é‡åŠ¨æ€è®¾ç½®æ–‡æœ¬å®é™…å®½åº¦ */
				max-width: var(--info-wrapper-width, 0px);
				opacity: 1;
				margin-left: clamp(8px, 3%, 3%);
				white-space: nowrap;
				overflow: hidden; /* ä¿ç•™ overflow: hidden ç”¨äºè£å‰ª */
				position: relative; /* ä¸ºæ¸å˜é®ç½©å®šä½ */

				/* ä½¿ç”¨ mask-image åˆ›å»ºå³ä¾§æ¸éšæ•ˆæœ */
				/* é€šè¿‡ CSS å˜é‡ç²¾ç¡®æ§åˆ¶æ¸éšèµ·å§‹ä½ç½®ï¼Œç¡®ä¿æ–‡æœ¬å®Œå…¨å¯è§ */
				--mask-fade-start: calc(
					100% - var(--mask-fade-width, 20px)
				); /* æ¸éšèµ·å§‹ä½ç½® */
				--mask-fade-width: 20px; /* æ¸éšåŒºåŸŸå®½åº¦ */
				mask-image: linear-gradient(
					to right,
					black 0,
					black var(--mask-fade-start),
					transparent 100%
				);
				-webkit-mask-image: linear-gradient(
					to right,
					black 0,
					black var(--mask-fade-start),
					transparent 100%
				);
				mask-size: 100% 100%;
				-webkit-mask-size: 100% 100%;
				mask-repeat: no-repeat;
				-webkit-mask-repeat: no-repeat;
				mask-position: center;
				-webkit-mask-position: center;

				transition: max-width 0.5s cubic-bezier(0.19, 1, 0.22, 1),
					opacity 0.5s cubic-bezier(0.19, 1, 0.22, 1),
					margin-left 0.5s cubic-bezier(0.19, 1, 0.22, 1),
					padding-right 0.5s cubic-bezier(0.19, 1, 0.22, 1);
			}

			/* ç®€å•æ¨¡å¼ä¸”éèšç„¦çŠ¶æ€ - æ”¶èµ· */
			.card.simple-mode:not(.focused) .info-wrapper {
				max-width: 0px;
				margin-left: 0%;
				padding-right: 0px;
				opacity: 0;
			}

			/* æ–‡æœ¬æ ·å¼ */
			.file-name {
				font-size: 30px;
				font-weight: 600;
				color: #ffffff;
				text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
				letter-spacing: 0.8px;
			}

			/* å ä½ç¬¦å›¾æ ‡ */
			.placeholder {
				font-size: 20px;
			}
		</style>
	</head>
	<body>
		<div class="card" id="mainCard" onclick="openFile()">
			<div class="icon-wrapper" id="iconWrapper">
				<div class="placeholder">ğŸ“„</div>
			</div>

			<div class="info-wrapper">
				<div class="file-name" id="fileName">æœªé€‰æ‹©æ–‡ä»¶</div>
			</div>
		</div>

		<script>
			let bridge = null;
			let currentThemeColor = "#007ACC";
			let currentFileColor = null; // {r, g, b, a}
			let currentIconUrl = null; // å½“å‰ icon å›¾ç‰‡ URL
			let isFocused = false;

			CSS.registerProperty({
				name: "--gradient-stop",
				initialValue: "10%",
				syntax: "<percentage>",
				inherits: false,
			});

			// åˆå§‹åŒ– WebChannel
			new QWebChannel(qt.webChannelTransport, function (channel) {
				bridge = channel.objects.bridge;

				if (!bridge) {
					console.error("Bridge not found");
					return;
				}

				// 1. è¿æ¥ä¿¡å·
				bridge.proxyFilePathChanged.connect(updateContent);
				bridge.proxyFileRemoved.connect(onFileRemoved);
				bridge.unitInfoChanged.connect(updateFocusState);

				// æ ·å¼ç›¸å…³çš„ä¿¡å· (å‡è®¾ styleHelper ä¼šè§¦å‘é‡æ–°åŠ è½½æˆ–æœ‰ä¿¡å·ï¼Œè¿™é‡Œä¸»è¦ä¾èµ– unitInfoChanged è§¦å‘é‡ç»˜æˆ–ä¸»åŠ¨è½®è¯¢)
				// å®é™…ä¸Šä¸»é¢˜è‰²é€šå¸¸æ¯”è¾ƒç¨³å®šï¼Œæˆ‘ä»¬å¯ä»¥åœ¨åˆå§‹åŒ–å’Œæ¯æ¬¡æ›´æ–°æ—¶è·å–

				// 2. åˆå§‹åŒ–æ•°æ®
				init();
			});

			async function init() {
				// è·å–åˆå§‹ä¸»é¢˜è‰²
				try {
					const color = await bridge.getThemeColor();
					if (color) currentThemeColor = color;
				} catch (e) {}

				updateContent();
				updateFocusState();
				bridge.setGlobalRoundCornerEnabled(false);
			}

			// === æµ‹é‡æ–‡æœ¬å®é™…å®½åº¦ ===
			function measureTextWidth() {
				const fileName = document.getElementById("fileName");
				const infoWrapper = document.querySelector(".info-wrapper");
				const card = document.getElementById("mainCard");

				if (!fileName || !infoWrapper || !card) return 0;

				// ä¸´æ—¶ç§»é™¤ max-width é™åˆ¶å’Œ overflow éšè—ä»¥æµ‹é‡å®é™…å®½åº¦
				const originalMaxWidth = infoWrapper.style.maxWidth;
				const originalOverflow = infoWrapper.style.overflow;
				infoWrapper.style.maxWidth = "none";
				infoWrapper.style.overflow = "visible";

				// å¼ºåˆ¶é‡æ’ä»¥è·å–å‡†ç¡®å°ºå¯¸
				void infoWrapper.offsetWidth;

				// æµ‹é‡æ–‡æœ¬å®¹å™¨çš„å®é™…å®½åº¦ï¼ˆåŒ…æ‹¬ padding å’Œ marginï¼‰
				const textWidth = Math.ceil(
					fileName.scrollWidth || fileName.offsetWidth
				);

				// æ¢å¤åŸå§‹æ ·å¼
				infoWrapper.style.maxWidth = originalMaxWidth;
				infoWrapper.style.overflow = originalOverflow;

				// åŠ¨æ€è°ƒæ•´é®ç½©æ¸éšå®½åº¦ï¼šæ ¹æ®æ–‡æœ¬å®½åº¦è‡ªé€‚åº”
				// æ–‡æœ¬å®½åº¦è¾ƒå°æ—¶ï¼Œæ¸éšåŒºåŸŸç›¸åº”ç¼©å°ï¼Œæœ€å° 8pxï¼Œæœ€å¤§ 20px
				const fadeWidth = Math.min(20, Math.max(8, textWidth * 0.12));

				// è®¾ç½® CSS å˜é‡ï¼Œç”¨äºåŠ¨ç”»
				// å®¹å™¨å®½åº¦ = æ–‡æœ¬å®½åº¦ + å³ä¾§è¾¹è· + æ¸éšåŒºåŸŸ
				// ç¡®ä¿æ–‡æœ¬å®Œå…¨å¯è§ï¼šæ–‡æœ¬å³è¾¹ç¼˜ + è¾¹è·åæ‰å¼€å§‹æ¸éš
				const rightMargin = 30; // æ–‡æœ¬å³ä¾§è¾¹è·ï¼Œå¢åŠ ä»¥ç¡®ä¿æ–‡æœ¬å’Œæ¸éšåŒºåŸŸä¹‹é—´æœ‰è¶³å¤Ÿç©ºé—´
				const finalWidth = textWidth + rightMargin + fadeWidth;
				card.style.setProperty("--info-wrapper-width", `${finalWidth}px`);

				// ç²¾ç¡®è®¡ç®—æ¸éšèµ·å§‹ä½ç½®ï¼ˆç™¾åˆ†æ¯”ï¼‰ï¼Œç¡®ä¿åœ¨æ–‡æœ¬å³è¾¹ç¼˜ä¹‹å
				// æ¸éšèµ·å§‹ä½ç½® = (æ–‡æœ¬å®½åº¦ + è¾¹è·) / å®¹å™¨æ€»å®½åº¦ * 100%
				const fadeStartPercent = (
					((textWidth + rightMargin) / finalWidth) *
					100
				).toFixed(2);
				infoWrapper.style.setProperty(
					"--mask-fade-start",
					`${fadeStartPercent}%`
				);

				// è®¾ç½®é®ç½©æ¸éšå®½åº¦
				infoWrapper.style.setProperty("--mask-fade-width", `${fadeWidth}px`);

				return finalWidth;
			}

			// === æ ¸å¿ƒé€»è¾‘ï¼šæ›´æ–°å†…å®¹ ===
			async function updateContent() {
				if (!bridge) return;

				const filePath = bridge.proxyFilePath;

				// 1. è·å–æ–‡ä»¶å
				let name = "æœªé€‰æ‹©æ–‡ä»¶";
				if (filePath) {
					try {
						const n = await bridge.getProxyFileName(filePath);
						if (n) name = n;
					} catch (e) {
						console.log("Get name failed", e);
					}
				}
				document.getElementById("fileName").textContent = name;

				// æµ‹é‡å¹¶æ›´æ–°æ–‡æœ¬å®½åº¦ï¼ˆä½¿ç”¨ requestAnimationFrame ç¡®ä¿ DOM å·²æ›´æ–°ï¼‰
				requestAnimationFrame(() => {
					measureTextWidth();
				});

				// 2. è·å–å›¾æ ‡
				const iconWrapper = document.getElementById("iconWrapper");
				if (filePath) {
					try {
						const iconData = await bridge.getProxyFileIcon(filePath);
						if (iconData) {
							currentIconUrl = iconData; // ä¿å­˜ icon URL ç”¨äºèƒŒæ™¯
							iconWrapper.innerHTML = `<img src="${iconData}" class="icon-img" onerror="this.style.display='none'">`;
						} else {
							currentIconUrl = null;
							iconWrapper.innerHTML = `<div class="placeholder">ğŸ“„</div>`;
						}
					} catch (e) {
						currentIconUrl = null;
						iconWrapper.innerHTML = `<div class="placeholder">ğŸ“„</div>`;
					}
				} else {
					currentIconUrl = null;
					iconWrapper.innerHTML = `<div class="placeholder">â•</div>`;
				}

				// 3. è·å–æ–‡ä»¶é¢œè‰²å¹¶æ›´æ–°èƒŒæ™¯
				if (filePath) {
					try {
						const colorJson = await bridge.getProxyFileColor(filePath);
						if (colorJson) {
							currentFileColor = JSON.parse(colorJson);
						} else {
							currentFileColor = null;
						}
					} catch (e) {
						currentFileColor = null;
					}
				} else {
					currentFileColor = null;
				}

				updateBackground();
			}

			// === æ ¸å¿ƒé€»è¾‘ï¼šæ›´æ–° Icon èƒŒæ™¯ ===
			function updateIconBackground() {
				const card = document.getElementById("mainCard");

				// æ›´æ–° isFocused çŠ¶æ€
				isFocused = bridge.unitInfo
					? JSON.parse(bridge.unitInfo).isFocus
					: false;

				// è®¾ç½® icon èƒŒæ™¯ URL
				if (currentIconUrl) {
					card.style.setProperty("--icon-bg-url", `url("${currentIconUrl}")`);
					// èšç„¦æ—¶æ˜¾ç¤ºæ·¡æ·¡çš„èƒŒæ™¯ï¼Œéèšç„¦æ—¶éšè—
					card.style.setProperty("--icon-bg-opacity", isFocused ? "0.05" : "0");
				} else {
					card.style.setProperty("--icon-bg-url", "none");
					card.style.setProperty("--icon-bg-opacity", "0");
				}
			}

			// === æ ¸å¿ƒé€»è¾‘ï¼šæ›´æ–°èƒŒæ™¯æ¸å˜ ===
			function updateBackground() {
				const card = document.getElementById("mainCard");

				// è§£æä¸»é¢˜è‰² Hex -> RGB
				const themeRgb = hexToRgb(currentThemeColor) || {
					r: 0,
					g: 122,
					b: 204,
				};

				let color1, color2;

				if (currentFileColor) {
					// å¦‚æœæœ‰æ–‡ä»¶è‰²ï¼Œå·¦ä¾§ä½¿ç”¨æ–‡ä»¶è‰²ï¼Œå³ä¾§ä½¿ç”¨ä¸»é¢˜è‰²æ··åˆ
					color1 = `rgba(${currentFileColor.r}, ${currentFileColor.g}, ${currentFileColor.b}, 0.6)`;
					color2 = `rgba(${themeRgb.r}, ${themeRgb.g}, ${themeRgb.b}, 0.2)`;
				} else {
					// é»˜è®¤çŠ¶æ€
					color1 = `rgba(${themeRgb.r}, ${themeRgb.g}, ${themeRgb.b}, 0.4)`;
					color2 = `rgba(${themeRgb.r}, ${themeRgb.g}, ${themeRgb.b}, 0.1)`;
				}

				// æ›´æ–° CSS å˜é‡ï¼Œæ”¯æŒåŠ¨ç”»æ’å€¼
				// ä½¿ç”¨ 135deg å®ç°å·¦ä¸Šåˆ°å³ä¸‹çš„å…‰æ„Ÿ
				isFocused = bridge.unitInfo
					? JSON.parse(bridge.unitInfo).isFocus
					: false;
				console.log("unitInfo", bridge.unitInfo);

				// è®¾ç½®å¯æ’å€¼çš„ CSS å˜é‡
				card.style.setProperty("--gradient-color1", color1);
				card.style.setProperty("--gradient-color2", color2);

				console.log(
					"updateBackground",
					`color1: ${color1}, color2: ${color2}, stop: ${
						isFocused ? "30%" : "10%"
					}`,
					bridge.unitInfo ? JSON.parse(bridge.unitInfo).isFocus : false
				);

				// åŠ¨æ€è¾¹æ¡†é¢œè‰²
				if (currentFileColor) {
					card.style.borderColor = `rgba(${currentFileColor.r}, ${currentFileColor.g}, ${currentFileColor.b}, 0.3)`;
				}

				// æ›´æ–° icon èƒŒæ™¯
				updateIconBackground();
			}

			// === æ ¸å¿ƒé€»è¾‘ï¼šç„¦ç‚¹çŠ¶æ€åˆ‡æ¢ ===
			function updateFocusState() {
				if (!bridge) return;
				console.log("updateFocusState");

				try {
					// bridge.unitInfo æ˜¯ JSON å­—ç¬¦ä¸²
					const infoStr = bridge.unitInfo; // è®¿é—®å±æ€§
					if (!infoStr) return;

					const info = JSON.parse(infoStr);
					const focused = info.isFocus;
					const simpleMode = info.simpleMode;

					const card = document.getElementById("mainCard");
					if (focused) {
						card.classList.add("focused");
						// èšç„¦æ—¶é‡æ–°è·å–ä¸€ä¸‹ä¸»é¢˜è‰²ï¼Œç¡®ä¿æ˜¯æœ€æ–°çš„
						bridge.getThemeColor().then((c) => {
							if (c && c !== currentThemeColor) {
								currentThemeColor = c;
								updateBackground();
							}
						});
					} else {
						card.classList.remove("focused");
					}
					if (simpleMode) {
						card.classList.add("simple-mode");
					} else {
						card.classList.remove("simple-mode");
					}
				} catch (e) {
					console.error("Parse unit info failed", e);
				}
				updateBackground(); // è¿™ä¼šåŒæ—¶æ›´æ–°æ¸å˜èƒŒæ™¯å’Œ icon èƒŒæ™¯
			}

			function onFileRemoved() {
				currentFileColor = null;
				updateContent();
			}

			function openFile() {
				if (bridge) {
					return;
					// ç®€å•çš„é˜²æŠ–æˆ–äº¤äº’åé¦ˆ
					const card = document.getElementById("mainCard");
					card.style.transform = "scale(0.95)";
					setTimeout(() => (card.style.transform = ""), 150);

					bridge.openProxyFile();
				}
			}

			// å·¥å…·ï¼šHex è½¬ RGB
			function hexToRgb(hex) {
				var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
				return result
					? {
							r: parseInt(result[1], 16),
							g: parseInt(result[2], 16),
							b: parseInt(result[3], 16),
					  }
					: null;
			}
		</script>
	</body>
</html>
